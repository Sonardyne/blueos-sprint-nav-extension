# Copyright 2024 Sonardyne

# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the “Software”), to deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
# Software.

# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import time
import sys
sys.path.append("../")

from hnavDecode import HNavDecode
import threading

def push_multiple(hn, bytes):
    for b in bytes:
        hn.pushBytes(b)

def test_working_normally():
    bytes = [0xaa, 0xbf, 0x00, 0x00, 0x00, 0x37, 0x00, 0x86,
             0xde, 0xad, 0x00, 0x9c, 0x0e, 0x78, 0x03, 0x69,
             0xcc, 0x05, 0x00, 0x86, 0xea, 0x00, 0x49, 0xfc,
             0xdd, 0x67, 0xff, 0x79, 0xff, 0xff, 0xff, 0x00,
             0x00, 0xee, 0xff, 0xac, 0xff, 0xd3, 0x33, 0xfa,
             0xff, 0xfa, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x3a, 0xc6, 0xf1, 0x07, 0x49,
             0x63, 0xff, 0x3f, 0xb7, 0x01, 0x6b, 0x00, 0x8a,
             0x00, 0x93, 0xd0]

    hn = HNavDecode()
    decodeThread = threading.Thread(target=hn.decodeBytes, args=())
    decodeThread.start()
    push_multiple(hn, bytes)
    time.sleep(0.1)
    hn.popDecodedMessages(timeout=0.01)
    hn.stop()

def test_checksum_error():
    bytes1_with_error = [0xaa, 0xbf, 0x00, 0x00, 0x00, 0x37, 0x00, 0x86,
             0xde, 0xad, 0x00, 0x9c, 0x0e, 0x78, 0x03, 0x69,
             0xcc, 0x05, 0x00, 0x86, 0xea, 0x00, 0x49, 0xfc,
             0xdd, 0x67, 0xff, 0x79, 0xff, 0xff, 0xff, 0x00,
             0x00, 0xee, 0xff, 0xac, 0xff, 0xd3, 0x33, 0xfa,
             0xff, 0xfa, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x3a, 0xc6, 0xf1, 0x07, 0x49,
             0x63, 0xff, 0x3f, 0xb7, 0x01, 0x6b, 0x00, 0x8a,
             0x00, 0x93, 0xd1]

    bytes2 = [0xaa, 0xbf, 0x00, 0x00, 0x00, 0x37, 0x00, 0x86,
              0xde, 0xad, 0x00, 0x9c, 0x0e, 0x78, 0x03, 0x69,
              0xcc, 0x05, 0x00, 0x86, 0xea, 0x00, 0x49, 0xfc,
              0xdd, 0x67, 0xff, 0x79, 0xff, 0xff, 0xff, 0x00,
              0x00, 0xee, 0xff, 0xac, 0xff, 0xd3, 0x33, 0xfa,
              0xff, 0xfa, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
              0x00, 0x00, 0x00, 0x3a, 0xc6, 0xf1, 0x07, 0x49,
              0x63, 0xff, 0x3f, 0xb7, 0x01, 0x6b, 0x00, 0x8a,
              0x00, 0x93, 0xd0]

    hn = HNavDecode()
    decodeThread = threading.Thread(target=hn.decodeBytes, args=())
    decodeThread.start()
    push_multiple(hn, bytes1_with_error)
    push_multiple(hn, bytes2)
    time.sleep(0.1)
    try:
        a = hn.popDecodedMessages(timeout=0.01)
    except:
        print("no messages found")
        assert(False)
    hn.stop()


def test_delay_in_bytes_arriving():
    bytes = [0xaa, 0xbf, 0x00, 0x00, 0x00, 0x37, 0x00, 0x86,
             0xde, 0xad, 0x00, 0x9c, 0x0e, 0x78, 0x03, 0x69,
             0xcc, 0x05, 0x00, 0x86, 0xea, 0x00, 0x49, 0xfc,
             0xdd, 0x67, 0xff, 0x79, 0xff, 0xff, 0xff, 0x00,
             0x00, 0xee, 0xff, 0xac, 0xff, 0xd3, 0x33, 0xfa,
             0xff, 0xfa, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x3a, 0xc6, 0xf1, 0x07, 0x49,
             0x63, 0xff, 0x3f, 0xb7, 0x01, 0x6b, 0x00, 0x8a,
             0x00, 0x93, 0xd0]

    hn = HNavDecode()
    decodeThread = threading.Thread(target=hn.decodeBytes, args=())
    decodeThread.daemon = True
    decodeThread.start()
    push_multiple(hn, bytes[0:2])
    time.sleep(0.01)
    push_multiple(hn, bytes[2:])
    time.sleep(0.1)
    try:
        a = hn.popDecodedMessages(timeout=0.01)
    except:
        print("no messages found")
        assert(False)
    hn.stop()

